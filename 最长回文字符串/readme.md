# 题目
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

# 实例1
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```
# 实例2
```
输入: "cbbd"
输出: "bb"
```

# 思路
1. 暴力
* 一个方法，判断字符串是否为回文
* 一个指针从头遍历数组
* 一个指针从后往前指，如果遇到跟前指针一样的字符，将字符串捞出判断是否回文

2. 动态规划
* 一个二维数组DP
* 按照字符串长度，从一到总长度
* 每个长度，遍历字符串，起点start设置为遍历的值i，终点值为i+当前遍历长度
* 长度为1时，DP[start][end]总为true；2时，判断str[start] === start[end]是否为true；其他情况判断str[start] === strt[end]以及DP[start + 1][end - 1]是否为true。
* DP[start][end]为true的时候，判读end - start - 1是否大于存储result，大于就替换

3. 中心扩散
遍历字符串，然后向两边扩散，找出回文字符串；需要考虑奇偶数情况


